
# 2025-11-22 15:09:51.874628
+Code the following app
+```
+// page.tsx
+"use client";
+import React, { useEffect, useState } from "react";
+
+/**
+ * Single-file First-Person Boxing Game
+ * - Paste this entire file into page.tsx and choose "Replace"
+ * - No external imports except react
+ * - All UI, CSS and logic inside this file
+ *
+ * Screenshot path (optional): /mnt/data/Screenshot_20251122_085401_Base.jpg
+ */
+
+export default function Page() {
+  const [npcHealth, setNpcHealth] = useState(100);
+  const [playerHealth, setPlayerHealth] = useState(100);
+  const [npcStatus, setNpcStatus] = useState("");
+  const [playerStatus, setPlayerStatus] = useState("");
+  const [playerBlocking, setPlayerBlocking] = useState(false);
+  const [playerDodging, setPlayerDodging] = useState(false);
+  const [gameOver, setGameOver] = useState(false);
+
+  // animation flags
+  const [npcHitAnim, setNpcHitAnim] = useState(false);
+  const [npcAttackAnim, setNpcAttackAnim] = useState(false);
+
+  useEffect(() => {
+    if (npcHealth <= 0 && !gameOver) {
+      setGameOver(true);
+      setPlayerStatus("You Win!");
+    }
+    if (playerHealth <= 0 && !gameOver) {
+      setGameOver(true);
+      setPlayerStatus("You Lose!");
+    }
+  }, [npcHealth, playerHealth, gameOver]);
+
+  // utility: random int inclusive
+  const randInt = (min: number, max: number) =>
+    Math.floor(Math.random() * (max - min + 1)) + min;
+
+  // Ensure health not below 0
+  const clampHealth = (value: number) => Math.max(0, Math.floor(value));
+
+  // NPC turn must only update playerHealth
+  const npcTurn = () => {
+    if (gameOver) return;
+    // small delay to make sequence readable
+    setTimeout(() => {
+      // choose attack
+      const attacks = [
+        { name: "Jab", dmg: randInt(5, 7) },
+        { name: "Hook", dmg: randInt(8, 10) },
+        { name: "Uppercut", dmg: randInt(10, 12) },
+      ];
+      const choice = attacks[Math.floor(Math.random() * attacks.length)];
+
+      // check dodge first
+      let finalDamage = choice.dmg;
+      let missed = false;
+      if (playerDodging) {
+        const dodgeSuccess = Math.random() < 0.5; // 50% chance to avoid
+        if (dodgeSuccess) {
+          missed = true;
+          finalDamage = 0;
+        }
+      }
+
+      // check blocking (applies even if attempted dodge failed)
+      if (!missed && playerBlocking) {
+        finalDamage = Math.max(0, Math.round(finalDamage * 0.3)); // reduce by 70%
+      }
+
+      // update status
+      setNpcStatus(`NPC uses ${choice.name}${missed ? " (missed)!" : "!"}`);
+      setNpcAttackAnim(true);
+
+      // apply damage
+      setPlayerHealth((prev) => {
+        const newHp = clampHealth(prev - finalDamage);
+        return newHp;
+      });
+
+      // clear defensive states after NPC attack (they apply only to next hit)
+      setPlayerBlocking(false);
+      setPlayerDodging(false);
+
+      // short animation toggles
+      setTimeout(() => setNpcAttackAnim(false), 250);
+    }, 200);
+  };
+
+  // Player attack helper - ONLY modifies npcHealth
+  const playerAttack = (baseDamage: number, attackName: string) => {
+    if (gameOver) return;
+
+    // clear defenses except ones set by the action
+    setPlayerBlocking(false);
+    setPlayerDodging(false);
+    setPlayerStatus(`You use ${attackName}!`);
+
+    // damage has slight randomness for variety
+    const damage = Math.max(1, Math.round(baseDamage + (Math.random() * 3 - 1)));
+
+    // apply to npcHealth only
+    setNpcHealth((prev) => {
+      const newHp = clampHealth(prev - damage);
+      return newHp;
+    });
+
+    // show hit animation on NPC
+    setNpcHitAnim(true);
+    setTimeout(() => setNpcHitAnim(false), 200);
+
+    // call npcTurn after short delay
+    setTimeout(() => {
+      // only call npcTurn if NPC still alive
+      setTimeout(() => {
+        if (!gameOver && npcHealth - damage > 0) {
+          npcTurn();
+        } else {
+          // ensure npcTurn doesn't run if NPC died
+        }
+      }, 50);
+    }, 250);
+  };
+
+  const playerLeftCut = () => playerAttack(randInt(8, 12), "Left Cut");
+  const playerRightCut = () => playerAttack(randInt(8, 12), "Right Cut");
+  const playerUpperCut = () => playerAttack(randInt(12, 15), "Uppercut");
+
+  const playerBlockAction = () => {
+    if (gameOver) return;
+    setPlayerBlocking(true);
+    setPlayerDodging(false);
+    setPlayerStatus("You raise a block!");
+    // NPC still gets a turn
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const playerDodgeLeft = () => {
+    if (gameOver) return;
+    setPlayerDodging(true);
+    setPlayerBlocking(false);
+    setPlayerStatus("You dodge left!");
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const playerDodgeRight = () => {
+    if (gameOver) return;
+    setPlayerDodging(true);
+    setPlayerBlocking(false);
+    setPlayerStatus("You dodge right!");
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const tryAgain = () => {
+    setNpcHealth(100);
+    setPlayerHealth(100);
+    setNpcStatus("");
+    setPlayerStatus("");
+    setPlayerBlocking(false);
+    setPlayerDodging(false);
+    setGameOver(false);
+    setNpcHitAnim(false);
+    setNpcAttackAnim(false);
+  };
+
+  // If either <= 0 set gameOver and status — handled in effect
+  useEffect(() => {
+    if (npcHealth <= 0) {
+      setGameOver(true);
+      setPlayerStatus("You Win!");
+    } else if (playerHealth <= 0) {
+      setGameOver(true);
+      setPlayerStatus("You Lose!");
+    }
+  }, [npcHealth, playerHealth]);
+
+  // Percentage widths for health bars
+  const npcHpPct = Math.max(0, Math.min(100, npcHealth));
+  const playerHpPct = Math.max(0, Math.min(100, playerHealth));
+
+  // Inline styles (kept simple)
+  const styles: { [k: string]: React.CSSProperties } = {
+    page: {
+      minHeight: "100vh",
+      boxSizing: "border-box",
+      padding: 16,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      fontFamily:
+        '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial',
+      background: "#fff",
+      color: "#111",
+    },
+    title: { fontSize: 20, fontWeight: 600, marginTop: 6, marginBottom: 16 },
+    healthBarContainer: {
+      width: "90%",
+      maxWidth: 420,
+      height: 18,
+      background: "#eee",
+      borderRadius: 12,
+      overflow: "hidden",
+      marginBottom: 8,
+    },
+    npcBar: { height: "100%", background: "#e74c3c", borderRadius: 12 },
+    playerBar: { height: "100%", background: "#2ecc71", borderRadius: 12 },
+    centerArea: {
+      width: "100%",
+      maxWidth: 420,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      marginTop: 10,
+      marginBottom: 12,
+    },
+    npcBody: {
+      marginTop: 8,
+      width: 220,
+      height: 240,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      justifyContent: "flex-start",
+      transition: "transform 0.15s ease",
+    },
+    npcHead: {
+      width: 72,
+      height: 72,
+      borderRadius: "50%",
+      background: "#f1c27d",
+      marginTop: 6,
+      boxShadow: "0 2px 0 rgba(0,0,0,0.06)",
+    },
+    npcTorso: {
+      width: 120,
+      height: 120,
+      borderRadius: 12,
+      background: "#3b82f6",
+      marginTop: 8,
+      position: "relative",
+      display: "flex",
+      alignItems: "center",
+      justifyContent: "center",
+    },
+    arm: {
+      width: 14,
+      height: 70,
+      background: "#3b82f6",
+      position: "absolute",
+      top: 10,
+      borderRadius: 8,
+      transformOrigin: "top center",
+      transition: "transform 0.15s ease",
+    },
+    leftArm: {
+      left: -28,
+      transform: "rotate(-20deg)",
+    },
+    rightArm: {
+      right: -28,
+      transform: "rotate(20deg)",
+    },
+    glove: {
+      width: 26,
+      height: 26,
+      borderRadius: "50%",
+      background: "#e74c3c",
+      position: "absolute",
+      bottom: -10,
+      boxShadow: "0 2px 0 rgba(0,0,0,0.12)",
+      transition: "transform 0.15s ease",
+    },
+    legs: {
+      width: 140,
+      height: 40,
+      marginTop: 6,
+      display: "flex",
+      justifyContent: "space-between",
+    },
+    leg: {
+      width: 34,
+      height: 40,
+      background: "#333",
+      borderRadius: 6,
+    },
+    statusText: { minHeight: 28, marginTop: 8, marginBottom: 6 },
+    buttonsGrid: {
+      display: "grid",
+      gridTemplateColumns: "1fr 1fr 1fr",
+      gap: 10,
+      width: "90%",
+      maxWidth: 420,
+      marginTop: 12,
+    },
+    btn: {
+      padding: "12px 8px",
+      borderRadius: 12,
+      border: "1px solid rgba(0,0,0,0.08)",
+      background: "#fff",
+      fontSize: 16,
+      fontWeight: 500,
+      boxShadow: "0 2px 6px rgba(0,0,0,0.03)",
+    },
+    tryAgainBtn: {
+      marginTop: 12,
+      padding: "12px 18px",
+      borderRadius: 14,
+      background: "#3b82f6",
+      color: "#fff",
+      fontWeight: 600,
+      border: "none",
+    },
+
+```
+
+Generate an app logo and update the app metadata title and description.

# 2025-11-22 15:09:51.877757
+Code the following app
+```
+// page.tsx
+"use client";
+import React, { useEffect, useState } from "react";
+
+/**
+ * Single-file First-Person Boxing Game
+ * - Paste this entire file into page.tsx and choose "Replace"
+ * - No external imports except react
+ * - All UI, CSS and logic inside this file
+ *
+ * Screenshot path (optional): /mnt/data/Screenshot_20251122_085401_Base.jpg
+ */
+
+export default function Page() {
+  const [npcHealth, setNpcHealth] = useState(100);
+  const [playerHealth, setPlayerHealth] = useState(100);
+  const [npcStatus, setNpcStatus] = useState("");
+  const [playerStatus, setPlayerStatus] = useState("");
+  const [playerBlocking, setPlayerBlocking] = useState(false);
+  const [playerDodging, setPlayerDodging] = useState(false);
+  const [gameOver, setGameOver] = useState(false);
+
+  // animation flags
+  const [npcHitAnim, setNpcHitAnim] = useState(false);
+  const [npcAttackAnim, setNpcAttackAnim] = useState(false);
+
+  useEffect(() => {
+    if (npcHealth <= 0 && !gameOver) {
+      setGameOver(true);
+      setPlayerStatus("You Win!");
+    }
+    if (playerHealth <= 0 && !gameOver) {
+      setGameOver(true);
+      setPlayerStatus("You Lose!");
+    }
+  }, [npcHealth, playerHealth, gameOver]);
+
+  // utility: random int inclusive
+  const randInt = (min: number, max: number) =>
+    Math.floor(Math.random() * (max - min + 1)) + min;
+
+  // Ensure health not below 0
+  const clampHealth = (value: number) => Math.max(0, Math.floor(value));
+
+  // NPC turn must only update playerHealth
+  const npcTurn = () => {
+    if (gameOver) return;
+    // small delay to make sequence readable
+    setTimeout(() => {
+      // choose attack
+      const attacks = [
+        { name: "Jab", dmg: randInt(5, 7) },
+        { name: "Hook", dmg: randInt(8, 10) },
+        { name: "Uppercut", dmg: randInt(10, 12) },
+      ];
+      const choice = attacks[Math.floor(Math.random() * attacks.length)];
+
+      // check dodge first
+      let finalDamage = choice.dmg;
+      let missed = false;
+      if (playerDodging) {
+        const dodgeSuccess = Math.random() < 0.5; // 50% chance to avoid
+        if (dodgeSuccess) {
+          missed = true;
+          finalDamage = 0;
+        }
+      }
+
+      // check blocking (applies even if attempted dodge failed)
+      if (!missed && playerBlocking) {
+        finalDamage = Math.max(0, Math.round(finalDamage * 0.3)); // reduce by 70%
+      }
+
+      // update status
+      setNpcStatus(`NPC uses ${choice.name}${missed ? " (missed)!" : "!"}`);
+      setNpcAttackAnim(true);
+
+      // apply damage
+      setPlayerHealth((prev) => {
+        const newHp = clampHealth(prev - finalDamage);
+        return newHp;
+      });
+
+      // clear defensive states after NPC attack (they apply only to next hit)
+      setPlayerBlocking(false);
+      setPlayerDodging(false);
+
+      // short animation toggles
+      setTimeout(() => setNpcAttackAnim(false), 250);
+    }, 200);
+  };
+
+  // Player attack helper - ONLY modifies npcHealth
+  const playerAttack = (baseDamage: number, attackName: string) => {
+    if (gameOver) return;
+
+    // clear defenses except ones set by the action
+    setPlayerBlocking(false);
+    setPlayerDodging(false);
+    setPlayerStatus(`You use ${attackName}!`);
+
+    // damage has slight randomness for variety
+    const damage = Math.max(1, Math.round(baseDamage + (Math.random() * 3 - 1)));
+
+    // apply to npcHealth only
+    setNpcHealth((prev) => {
+      const newHp = clampHealth(prev - damage);
+      return newHp;
+    });
+
+    // show hit animation on NPC
+    setNpcHitAnim(true);
+    setTimeout(() => setNpcHitAnim(false), 200);
+
+    // call npcTurn after short delay
+    setTimeout(() => {
+      // only call npcTurn if NPC still alive
+      setTimeout(() => {
+        if (!gameOver && npcHealth - damage > 0) {
+          npcTurn();
+        } else {
+          // ensure npcTurn doesn't run if NPC died
+        }
+      }, 50);
+    }, 250);
+  };
+
+  const playerLeftCut = () => playerAttack(randInt(8, 12), "Left Cut");
+  const playerRightCut = () => playerAttack(randInt(8, 12), "Right Cut");
+  const playerUpperCut = () => playerAttack(randInt(12, 15), "Uppercut");
+
+  const playerBlockAction = () => {
+    if (gameOver) return;
+    setPlayerBlocking(true);
+    setPlayerDodging(false);
+    setPlayerStatus("You raise a block!");
+    // NPC still gets a turn
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const playerDodgeLeft = () => {
+    if (gameOver) return;
+    setPlayerDodging(true);
+    setPlayerBlocking(false);
+    setPlayerStatus("You dodge left!");
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const playerDodgeRight = () => {
+    if (gameOver) return;
+    setPlayerDodging(true);
+    setPlayerBlocking(false);
+    setPlayerStatus("You dodge right!");
+    setTimeout(() => npcTurn(), 250);
+  };
+
+  const tryAgain = () => {
+    setNpcHealth(100);
+    setPlayerHealth(100);
+    setNpcStatus("");
+    setPlayerStatus("");
+    setPlayerBlocking(false);
+    setPlayerDodging(false);
+    setGameOver(false);
+    setNpcHitAnim(false);
+    setNpcAttackAnim(false);
+  };
+
+  // If either <= 0 set gameOver and status — handled in effect
+  useEffect(() => {
+    if (npcHealth <= 0) {
+      setGameOver(true);
+      setPlayerStatus("You Win!");
+    } else if (playerHealth <= 0) {
+      setGameOver(true);
+      setPlayerStatus("You Lose!");
+    }
+  }, [npcHealth, playerHealth]);
+
+  // Percentage widths for health bars
+  const npcHpPct = Math.max(0, Math.min(100, npcHealth));
+  const playerHpPct = Math.max(0, Math.min(100, playerHealth));
+
+  // Inline styles (kept simple)
+  const styles: { [k: string]: React.CSSProperties } = {
+    page: {
+      minHeight: "100vh",
+      boxSizing: "border-box",
+      padding: 16,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      fontFamily:
+        '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial',
+      background: "#fff",
+      color: "#111",
+    },
+    title: { fontSize: 20, fontWeight: 600, marginTop: 6, marginBottom: 16 },
+    healthBarContainer: {
+      width: "90%",
+      maxWidth: 420,
+      height: 18,
+      background: "#eee",
+      borderRadius: 12,
+      overflow: "hidden",
+      marginBottom: 8,
+    },
+    npcBar: { height: "100%", background: "#e74c3c", borderRadius: 12 },
+    playerBar: { height: "100%", background: "#2ecc71", borderRadius: 12 },
+    centerArea: {
+      width: "100%",
+      maxWidth: 420,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      marginTop: 10,
+      marginBottom: 12,
+    },
+    npcBody: {
+      marginTop: 8,
+      width: 220,
+      height: 240,
+      display: "flex",
+      flexDirection: "column",
+      alignItems: "center",
+      justifyContent: "flex-start",
+      transition: "transform 0.15s ease",
+    },
+    npcHead: {
+      width: 72,
+      height: 72,
+      borderRadius: "50%",
+      background: "#f1c27d",
+      marginTop: 6,
+      boxShadow: "0 2px 0 rgba(0,0,0,0.06)",
+    },
+    npcTorso: {
+      width: 120,
+      height: 120,
+      borderRadius: 12,
+      background: "#3b82f6",
+      marginTop: 8,
+      position: "relative",
+      display: "flex",
+      alignItems: "center",
+      justifyContent: "center",
+    },
+    arm: {
+      width: 14,
+      height: 70,
+      background: "#3b82f6",
+      position: "absolute",
+      top: 10,
+      borderRadius: 8,
+      transformOrigin: "top center",
+      transition: "transform 0.15s ease",
+    },
+    leftArm: {
+      left: -28,
+      transform: "rotate(-20deg)",
+    },
+    rightArm: {
+      right: -28,
+      transform: "rotate(20deg)",
+    },
+    glove: {
+      width: 26,
+      height: 26,
+      borderRadius: "50%",
+      background: "#e74c3c",
+      position: "absolute",
+      bottom: -10,
+      boxShadow: "0 2px 0 rgba(0,0,0,0.12)",
+      transition: "transform 0.15s ease",
+    },
+    legs: {
+      width: 140,
+      height: 40,
+      marginTop: 6,
+      display: "flex",
+      justifyContent: "space-between",
+    },
+    leg: {
+      width: 34,
+      height: 40,
+      background: "#333",
+      borderRadius: 6,
+    },
+    statusText: { minHeight: 28, marginTop: 8, marginBottom: 6 },
+    buttonsGrid: {
+      display: "grid",
+      gridTemplateColumns: "1fr 1fr 1fr",
+      gap: 10,
+      width: "90%",
+      maxWidth: 420,
+      marginTop: 12,
+    },
+    btn: {
+      padding: "12px 8px",
+      borderRadius: 12,
+      border: "1px solid rgba(0,0,0,0.08)",
+      background: "#fff",
+      fontSize: 16,
+      fontWeight: 500,
+      boxShadow: "0 2px 6px rgba(0,0,0,0.03)",
+    },
+    tryAgainBtn: {
+      marginTop: 12,
+      padding: "12px 18px",
+      borderRadius: 14,
+      background: "#3b82f6",
+      color: "#fff",
+      fontWeight: 600,
+      border: "none",
+    },
+
+```
+
+Generate an app logo and update the app metadata title and description.
